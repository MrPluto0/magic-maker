import{y as Q,m as V,f as z,p as A,u as H,r as D,d as O,w as K,b as W,x as Y,g as Z,R as J,C as T}from"./chunk-66ULMTWW-DsF6fhIy.js";import{p as q}from"./chunk-LA3PGSPR-DuQNQ5r_.js";import{u as U}from"./chunk-LA5IGN2Q-C91kziwX.js";import{j as X,R as _,Q as R,m as ee}from"./chunk-4IXHFASB-DHgp_pL0.js";import{b as n,X as B,d as N,V as I}from"./dist-QNDTTFGF-xyGUN-Ni.js";import{c as G}from"./index-KuFrev5g.js";G();function y(t){var e={options:{directed:t.isDirected(),multigraph:t.isMultigraph(),compound:t.isCompound()},nodes:re(t),edges:te(t)};return X(t.graph())||(e.value=_(t.graph())),e}function re(t){return R(t.nodes(),function(e){var r=t.node(e),a=t.parent(e),i={v:e};return X(r)||(i.value=r),X(a)||(i.parent=a),i})}function te(t){return R(t.edges(),function(e){var r=t.edge(e),a={v:e.v,w:e.w};return X(e.name)||(a.name=e.name),X(r)||(a.value=r),a})}G();var s={},u={},L={},ie=()=>{u={},L={},s={}},S=(t,e)=>(n.trace("In isDescendant",e," ",t," = ",u[e].includes(t)),!!u[e].includes(t)),ne=(t,e)=>(n.info("Descendants of ",e," is ",u[e]),n.info("Edge is ",t),t.v===e||t.w===e?!1:u[e]?u[e].includes(t.v)||S(t.v,e)||S(t.w,e)||u[e].includes(t.w):(n.debug("Tilt, ",e,",not in descendants"),!1)),k=(t,e,r,a)=>{n.warn("Copying children of ",t,"root",a,"data",e.node(t),a);let i=e.children(t)||[];t!==a&&i.push(t),n.warn("Copying (nodes) clusterId",t,"nodes",i),i.forEach(d=>{if(e.children(d).length>0)k(d,e,r,a);else{let g=e.node(d);n.info("cp ",d," to ",a," with parent ",t),r.setNode(d,g),a!==e.parent(d)&&(n.warn("Setting parent",d,e.parent(d)),r.setParent(d,e.parent(d))),t!==a&&d!==t?(n.debug("Setting parent",d,t),r.setParent(d,t)):(n.info("In copy ",t,"root",a,"data",e.node(t),a),n.debug("Not Setting parent for node=",d,"cluster!==rootId",t!==a,"node!==clusterId",d!==t));let f=e.edges(d);n.debug("Copying Edges",f),f.forEach(h=>{n.info("Edge",h);let c=e.edge(h.v,h.w,h.name);n.info("Edge data",c,a);try{ne(h,a)?(n.info("Copying as ",h.v,h.w,c,h.name),r.setEdge(h.v,h.w,c,h.name),n.info("newGraph edges ",r.edges(),r.edge(r.edges()[0]))):n.info("Skipping copy of edge ",h.v,"-->",h.w," rootId: ",a," clusterId:",t)}catch(w){n.error(w)}})}n.debug("Removing node",d),e.removeNode(d)})},F=(t,e)=>{let r=e.children(t),a=[...r];for(let i of r)L[i]=t,a=[...a,...F(i,e)];return a},E=(t,e)=>{n.trace("Searching",t);let r=e.children(t);if(n.trace("Searching children of id ",t,r),r.length<1)return n.trace("This is a valid node",t),t;for(let a of r){let i=E(a,e);if(i)return n.trace("Found replacement for",t," => ",i),i}},C=t=>!s[t]||!s[t].externalConnections?t:s[t]?s[t].id:t,ae=(t,e)=>{if(!t||e>10){n.debug("Opting out, no graph ");return}else n.debug("Opting in, graph ");t.nodes().forEach(function(r){t.children(r).length>0&&(n.warn("Cluster identified",r," Replacement id in edges: ",E(r,t)),u[r]=F(r,t),s[r]={id:E(r,t),clusterData:t.node(r)})}),t.nodes().forEach(function(r){let a=t.children(r),i=t.edges();a.length>0?(n.debug("Cluster identified",r,u),i.forEach(d=>{if(d.v!==r&&d.w!==r){let g=S(d.v,r),f=S(d.w,r);g^f&&(n.warn("Edge: ",d," leaves cluster ",r),n.warn("Descendants of XXX ",r,": ",u[r]),s[r].externalConnections=!0)}})):n.debug("Not a cluster ",r,u)});for(let r of Object.keys(s)){let a=s[r].id,i=t.parent(a);i!==r&&s[i]&&!s[i].externalConnections&&(s[r].id=i)}t.edges().forEach(function(r){let a=t.edge(r);n.warn("Edge "+r.v+" -> "+r.w+": "+JSON.stringify(r)),n.warn("Edge "+r.v+" -> "+r.w+": "+JSON.stringify(t.edge(r)));let i=r.v,d=r.w;if(n.warn("Fix XXX",s,"ids:",r.v,r.w,"Translating: ",s[r.v]," --- ",s[r.w]),s[r.v]&&s[r.w]&&s[r.v]===s[r.w]){n.warn("Fixing and trixing link to self - removing XXX",r.v,r.w,r.name),n.warn("Fixing and trixing - removing XXX",r.v,r.w,r.name),i=C(r.v),d=C(r.w),t.removeEdge(r.v,r.w,r.name);let g=r.w+"---"+r.v;t.setNode(g,{domId:g,id:g,labelStyle:"",labelText:a.label,padding:0,shape:"labelRect",style:""});let f=structuredClone(a),h=structuredClone(a);f.label="",f.arrowTypeEnd="none",h.label="",f.fromCluster=r.v,h.toCluster=r.v,t.setEdge(i,g,f,r.name+"-cyclic-special"),t.setEdge(g,d,h,r.name+"-cyclic-special")}else if(s[r.v]||s[r.w]){if(n.warn("Fixing and trixing - removing XXX",r.v,r.w,r.name),i=C(r.v),d=C(r.w),t.removeEdge(r.v,r.w,r.name),i!==r.v){let g=t.parent(i);s[g].externalConnections=!0,a.fromCluster=r.v}if(d!==r.w){let g=t.parent(d);s[g].externalConnections=!0,a.toCluster=r.w}n.warn("Fix Replacing with XXX",i,d,r.name),t.setEdge(i,d,a,r.name)}}),n.warn("Adjusted Graph",y(t)),$(t,0),n.trace(s)},$=(t,e)=>{if(n.warn("extractor - ",e,y(t),t.children("D")),e>10){n.error("Bailing out");return}let r=t.nodes(),a=!1;for(let i of r){let d=t.children(i);a=a||d.length>0}if(!a){n.debug("Done, no node has children",t.nodes());return}n.debug("Nodes = ",r,e);for(let i of r)if(n.debug("Extracting node",i,s,s[i]&&!s[i].externalConnections,!t.parent(i),t.node(i),t.children("D")," Depth ",e),!s[i])n.debug("Not a cluster",i,e);else if(!s[i].externalConnections&&t.children(i)&&t.children(i).length>0){n.warn("Cluster without external connections, without a parent and with children",i,e);let d=t.graph().rankdir==="TB"?"LR":"TB";s[i]&&s[i].clusterData&&s[i].clusterData.dir&&(d=s[i].clusterData.dir,n.warn("Fixing dir",s[i].clusterData.dir,d));let g=new ee({multigraph:!0,compound:!0}).setGraph({rankdir:d,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});n.warn("Old graph before copy",y(t)),k(i,t,g,i),t.setNode(i,{clusterNode:!0,id:i,clusterData:s[i].clusterData,labelText:s[i].labelText,graph:g}),n.warn("New graph after copy node: (",i,")",y(g)),n.debug("Old graph after copy",y(t))}else n.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!s[i].externalConnections," no parent: ",!t.parent(i)," children ",t.children(i)&&t.children(i).length>0,t.children("D"),e),n.debug(s);r=t.nodes(),n.warn("New list of nodes",r);for(let i of r){let d=t.node(i);n.warn(" Now next level",i,d),d.clusterNode&&$(d.graph,e+1)}},P=(t,e)=>{if(e.length===0)return[];let r=Object.assign(e);return e.forEach(a=>{let i=t.children(a),d=P(t,i);r=[...r,...d]}),r},de=t=>P(t,t.children()),oe=(t,e)=>{n.info("Creating subgraph rect for ",e.id,e);let r=B(),a=t.insert("g").attr("class","cluster"+(e.class?" "+e.class:"")).attr("id",e.id),i=a.insert("rect",":first-child"),d=N(r.flowchart.htmlLabels),g=a.insert("g").attr("class","cluster-label"),f=e.labelType==="markdown"?q(g,e.labelText,{style:e.labelStyle,useHtmlLabels:d}):g.node().appendChild(J(e.labelText,e.labelStyle,void 0,!0)),h=f.getBBox();if(N(r.flowchart.htmlLabels)){let o=f.children[0],l=I(f);h=o.getBoundingClientRect(),l.attr("width",h.width),l.attr("height",h.height)}let c=0*e.padding,w=c/2,p=e.width<=h.width+c?h.width+c:e.width;e.width<=h.width+c?e.diff=(h.width-e.width)/2-e.padding/2:e.diff=-e.padding/2,n.trace("Data ",e,JSON.stringify(e)),i.attr("style",e.style).attr("rx",e.rx).attr("ry",e.ry).attr("x",e.x-p/2).attr("y",e.y-e.height/2-w).attr("width",p).attr("height",e.height+c);let{subGraphTitleTopMargin:x}=D(r);d?g.attr("transform",`translate(${e.x-h.width/2}, ${e.y-e.height/2+x})`):g.attr("transform",`translate(${e.x}, ${e.y-e.height/2+x})`);let v=i.node().getBBox();return e.width=v.width,e.height=v.height,e.intersect=function(o){return T(e,o)},a},le=(t,e)=>{let r=t.insert("g").attr("class","note-cluster").attr("id",e.id),a=r.insert("rect",":first-child"),i=0*e.padding,d=i/2;a.attr("rx",e.rx).attr("ry",e.ry).attr("x",e.x-e.width/2-d).attr("y",e.y-e.height/2-d).attr("width",e.width+i).attr("height",e.height+i).attr("fill","none");let g=a.node().getBBox();return e.width=g.width,e.height=g.height,e.intersect=function(f){return T(e,f)},r},se=(t,e)=>{let r=B(),a=t.insert("g").attr("class",e.classes).attr("id",e.id),i=a.insert("rect",":first-child"),d=a.insert("g").attr("class","cluster-label"),g=a.append("rect"),f=d.node().appendChild(J(e.labelText,e.labelStyle,void 0,!0)),h=f.getBBox();if(N(r.flowchart.htmlLabels)){let o=f.children[0],l=I(f);h=o.getBoundingClientRect(),l.attr("width",h.width),l.attr("height",h.height)}h=f.getBBox();let c=0*e.padding,w=c/2,p=e.width<=h.width+e.padding?h.width+e.padding:e.width;e.width<=h.width+e.padding?e.diff=(h.width+e.padding*0-e.width)/2:e.diff=-e.padding/2,i.attr("class","outer").attr("x",e.x-p/2-w).attr("y",e.y-e.height/2-w).attr("width",p+c).attr("height",e.height+c),g.attr("class","inner").attr("x",e.x-p/2-w).attr("y",e.y-e.height/2-w+h.height-1).attr("width",p+c).attr("height",e.height+c-h.height-3);let{subGraphTitleTopMargin:x}=D(r);d.attr("transform",`translate(${e.x-h.width/2}, ${e.y-e.height/2-e.padding/3+(N(r.flowchart.htmlLabels)?5:3)+x})`);let v=i.node().getBBox();return e.height=v.height,e.intersect=function(o){return T(e,o)},a},he=(t,e)=>{let r=t.insert("g").attr("class",e.classes).attr("id",e.id),a=r.insert("rect",":first-child"),i=0*e.padding,d=i/2;a.attr("class","divider").attr("x",e.x-e.width/2-d).attr("y",e.y-e.height/2).attr("width",e.width+i).attr("height",e.height+i);let g=a.node().getBBox();return e.width=g.width,e.height=g.height,e.diff=-e.padding/2,e.intersect=function(f){return T(e,f)},r},ge={rect:oe,roundedWithTitle:se,noteGroup:le,divider:he},j={},fe=(t,e)=>{n.trace("Inserting cluster");let r=e.shape||"rect";j[e.id]=ge[r](t,e)},ce=()=>{j={}},M=async(t,e,r,a,i,d)=>{n.info("Graph in recursive render: XXX",y(e),i);let g=e.graph().rankdir;n.trace("Dir in recursive render - dir:",g);let f=t.insert("g").attr("class","root");e.nodes()?n.info("Recursive render XXX",e.nodes()):n.info("No nodes found for",e),e.edges().length>0&&n.trace("Recursive edges",e.edge(e.edges()[0]));let h=f.insert("g").attr("class","clusters"),c=f.insert("g").attr("class","edgePaths"),w=f.insert("g").attr("class","edgeLabels"),p=f.insert("g").attr("class","nodes");await Promise.all(e.nodes().map(async function(o){let l=e.node(o);if(i!==void 0){let m=JSON.parse(JSON.stringify(i.clusterData));n.info("Setting data for cluster XXX (",o,") ",m,i),e.setNode(i.id,m),e.parent(o)||(n.trace("Setting parent",o,i.id),e.setParent(o,i.id,m))}if(n.info("(Insert) Node XXX"+o+": "+JSON.stringify(e.node(o))),l&&l.clusterNode){n.info("Cluster identified",o,l.width,e.node(o));let m=await M(p,l.graph,r,a,e.node(o),d),b=m.elem;V(l,b),l.diff=m.diff||0,n.info("Node bounds (abc123)",o,l,l.width,l.x,l.y),z(b,l),n.warn("Recursive render complete ",b,l)}else e.children(o).length>0?(n.info("Cluster - the non recursive path XXX",o,l.id,l,e),n.info(E(l.id,e)),s[l.id]={id:E(l.id,e),node:l}):(n.info("Node - the non recursive path",o,l.id,l),await A(p,e.node(o),g))})),e.edges().forEach(function(o){let l=e.edge(o.v,o.w,o.name);n.info("Edge "+o.v+" -> "+o.w+": "+JSON.stringify(o)),n.info("Edge "+o.v+" -> "+o.w+": ",o," ",JSON.stringify(e.edge(o))),n.info("Fix",s,"ids:",o.v,o.w,"Translating: ",s[o.v],s[o.w]),H(w,l)}),e.edges().forEach(function(o){n.info("Edge "+o.v+" -> "+o.w+": "+JSON.stringify(o))}),n.info("#############################################"),n.info("###                Layout                 ###"),n.info("#############################################"),n.info(e),U(e),n.info("Graph after layout:",y(e));let x=0,{subGraphTitleTotalMargin:v}=D(d);return de(e).forEach(function(o){let l=e.node(o);n.info("Position "+o+": "+JSON.stringify(e.node(o))),n.info("Position "+o+": ("+l.x,","+l.y,") width: ",l.width," height: ",l.height),l&&l.clusterNode?(l.y+=v,O(l)):e.children(o).length>0?(l.height+=v,fe(h,l),s[l.id].node=l):(l.y+=v/2,O(l))}),e.edges().forEach(function(o){let l=e.edge(o);n.info("Edge "+o.v+" -> "+o.w+": "+JSON.stringify(l),l),l.points.forEach(b=>b.y+=v/2);let m=K(c,o,l,s,r,e,a);W(l,m)}),e.nodes().forEach(function(o){let l=e.node(o);n.info(o,l.type,l.diff),l.type==="group"&&(x=l.diff)}),{elem:f,diff:x}},xe=async(t,e,r,a,i)=>{Q(t,r,a,i),Y(),Z(),ce(),ie(),n.warn("Graph at first:",JSON.stringify(y(e))),ae(e),n.warn("Graph after:",JSON.stringify(y(e)));let d=B();await M(t,e,a,i,void 0,d)};export{xe as S};
